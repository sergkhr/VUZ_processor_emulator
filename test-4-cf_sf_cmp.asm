; ==========================================================
; ТЕСТ 1: Только CF (Unsigned Overflow)
; sum (250) + iterator (10) = 260.
; В 8 битах это 4 (260 - 256).
; Результат 4 положительный (SF=0), но было переполнение (CF=1).
; ==========================================================
MOV_LIT sum 250
MOV_LIT iterator 10
ADD reg3 sum iterator
; ОЖИДАНИЕ: reg3 = 4, CF = 1, SF = 0


; ==========================================================
; ТЕСТ 2: Только SF (Signed Negative)
; 100 + 50 = 150. В 8 битах это -106 (в знаковом представлении).
; 150 <= 255, переполнения беззнакового нет (CF=0).
; Но бит знака (старший) установлен -> SF=1.
; ==========================================================
MOV_LIT reg4 100
MOV_LIT reg5 50
ADD reg6 reg4 reg5
; ОЖИДАНИЕ: reg6 = -106 (150 unsigned), CF = 0, SF = 1


; ==========================================================
; ТЕСТ 3: И CF, и SF
; -1 (255) + -1 (255) = 510.
; 510 > 255 -> Есть перенос (CF=1).
; В 8 битах результат 254 (или -2). Число отрицательное -> SF=1.
; ==========================================================
MOV_LIT reg7 -1
MOV_LIT reg8 -1
ADD reg9 reg7 reg8
; ОЖИДАНИЕ: reg9 = -2 (254 unsigned), CF = 1, SF = 1


; ==========================================================
; ТЕСТ 4: Сравнение (CMP) и Заимствование
; 5 - 10.
; 5 < 10, при вычитании происходит заимствование -> CF=1.
; Результат -5 (отрицательный) -> SF=1.
; Синтаксис: CMP <заглушка> <op1> <op2>
; ==========================================================
MOV_LIT reg10 5
MOV_LIT reg11 10
CMP null reg10 reg11
; ОЖИДАНИЕ: Результат никуда не пишется, CF = 1, SF = 1