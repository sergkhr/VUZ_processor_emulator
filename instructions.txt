MOV (where to) (register) (placeholder)
MOV_LIT (register) (literal) (placeholder)

ADD (where to) (register) + (register)
CMP (placeholder) (register) - (register)

JMP/JZ/JNZ (mark name) (placeholder) (placeholder)

MARK (mark name) (placeholder) (placeholder)

VAR (mem name) (literal) (placeholder)
ARR_ALLOC (mem name) (length) (placeholder)

SET_MEM_OFFSET (mem name) (literal) (offset)
MOV_MEM_OFFSET (where to) (mem name) (offset)













reg1 - is for sum
reg2 - is for iterator

reg16 - is the answer registry


Пожалуйста делайте нормальный нейминг в функциях, особенно для принимаемых переменных

MOV_OFFSET не нужен

____

Команда
4 битов операции / 8 битов адреса / 8 битов адреса / 8 битов адреса

ОДНА ЯЧЕЙКА в памяти, в регистрах и т.д. занимает 1 БАЙТ
В регистре команд - 16 ячеек - адресация 4 бита
В регистрах - 16 регистров, (4 бита минимум, но пофиг)
В памяти 256 ячеек (по байту), адресация 8-битная

Литералы соответсвенно не более 255 - 0-255 256 разных значений

____
ТУДУ ЛИСТ
1) переводы в бинарный
1.1) четко разграничить команды и адреса в них по тому с чем они работают 
    прим.: регистры, память, литералы
1.2) бинарное представление для всех регистров 
    (регистры, память, команды, флаги, метки)
1.2.1) словари "название ячейки" - "бинарный код ячейки"
1.2.2) словари "бинарный код ячейки" - "хранимое в ячейке"
1.2.3) обновить визуализацию через 2 словаря -
    таблицаа из трехэлементов: слово-код-значение
1.3) сделать команды:
1.3.1) положить в память литерал
1.3.2) положить в регистр литерал

2) большая арифметика
3) свертка массива



TODO
- В executeStep поменять логику, и не пытаться получить данные или проверить наличие, все - в call command ил на компиляции